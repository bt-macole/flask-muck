{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Flask-Muck","text":"<p>Flask-Muck is a batteries-included framework for automatically generating RESTful APIs with Create, Read,  Update and Delete (CRUD) endpoints in a Flask/SqlAlchemy application stack. </p> <p>With Flask-Muck you don't have to worry about the CRUD.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Uses a declarative and modular approach to automatically generate CRUD endpoints.</li> <li>Built-in search, filter, sort and pagination when listing resources.</li> <li>Support for APIs with nested resources (i.e. /api/class/\\&lt;ID&gt;/students).</li> <li>Fully compatible with any other Flask method-based or class-based views. Mix &amp; match with your existing views.</li> <li>Pre and post callbacks configurable on all manipulation endpoints that allow for arbitrary logic before and after Create, Update or Delete operations.</li> <li>Supports Marshmallow and Pydantic for schema definitions.</li> </ul>"},{"location":"#license","title":"License","text":"<p>Flask-Muck is distributed under the MIT license.</p>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#flaskmuckapiview","title":"FlaskMuckApiView","text":"<p>             Bases: <code>MethodView</code></p> <p>Class representing a Flask API view for handling CRUD operations on a SQLAlchemy model.</p> <p>Attributes:</p> Name Type Description <code>session</code> <code>scoped_session</code> <p>The SQLAlchemy scoped session used for database operations.</p> <code>api_name</code> <code>str</code> <p>The name of the API.</p> <code>Model</code> <code>SqlaModelType</code> <p>The SQLAlchemy model for the API.</p> <code>parent</code> <code>Optional[type[FlaskMuckApiView]]</code> <p>The parent API view if this view is a child API view.</p> <code>ResponseSchema</code> <code>type[Serializer]</code> <p>The marshmallow schema or Pydantic model  for serializing the response data.</p> <code>CreateSchema</code> <code>Optional[type[Serializer]]</code> <p>The marshmallow schema or Pydantic model  for validating and serializing create data.</p> <code>UpdateSchema</code> <code>Optional[type[Serializer]]</code> <p>The marshmallow schema or Pydantic model  for validating and serializing update data.</p> <code>PatchSchema</code> <code>Optional[type[Serializer]]</code> <p>The marshmallow schema or Pydantic model  for validating and serializing patch data.</p> <code>DeleteSchema</code> <code>Optional[type[Serializer]]</code> <p>The marshmallow schema or Pydantic model  for validating and serializing delete data.</p> <code>DetailSchema</code> <code>Optional[type[Serializer]]</code> <p>The marshmallow schema or Pydantic model  for serializing detail data.</p> <code>pre_create_callbacks</code> <code>list[type[FlaskMuckCallback]]</code> <p>A list of pre-create callbacks.</p> <code>pre_update_callbacks</code> <code>list[type[FlaskMuckCallback]]</code> <p>A list of pre-update callbacks.</p> <code>pre_patch_callbacks</code> <code>list[type[FlaskMuckCallback]]</code> <p>A list of pre-patch callbacks.</p> <code>pre_delete_callbacks</code> <code>list[type[FlaskMuckCallback]]</code> <p>A list of pre-delete callbacks.</p> <code>post_create_callbacks</code> <code>list[type[FlaskMuckCallback]]</code> <p>A list of post-create callbacks.</p> <code>post_update_callbacks</code> <code>list[type[FlaskMuckCallback]]</code> <p>A list of post-update callbacks.</p> <code>post_patch_callbacks</code> <code>list[type[FlaskMuckCallback]]</code> <p>A list of post-patch callbacks.</p> <code>post_delete_callbacks</code> <code>list[type[FlaskMuckCallback]]</code> <p>A list of post-delete callbacks.</p> <code>searchable_columns</code> <code>list[InstrumentedAttribute]</code> <p>A list of columns that can be searched.</p> <code>default_pagination_limit</code> <code>int</code> <p>The default pagination limit.</p> <code>one_to_one_api</code> <code>bool</code> <p>Indicates whether the API represents a one-to-one relationship.</p> <code>allowed_methods</code> <code>set[str]</code> <p>A set of allowed HTTP methods.</p> <code>operator_separator</code> <code>str</code> <p>The separator used in filter operators.</p> Source code in <code>flask_muck/views.py</code> <pre><code>class FlaskMuckApiView(MethodView):\n    \"\"\"\n    Class representing a Flask API view for handling CRUD operations on a SQLAlchemy model.\n\n    Attributes:\n        session (scoped_session): The SQLAlchemy scoped session used for database operations.\n        api_name (str): The name of the API.\n        Model (SqlaModelType): The SQLAlchemy model for the API.\n        parent (Optional[type[FlaskMuckApiView]]): The parent API view if this view is a child API view.\n\n        ResponseSchema (type[Serializer]): The marshmallow schema or Pydantic model  for serializing the response data.\n        CreateSchema (Optional[type[Serializer]]): The marshmallow schema or Pydantic model  for validating and serializing create data.\n        UpdateSchema (Optional[type[Serializer]]): The marshmallow schema or Pydantic model  for validating and serializing update data.\n        PatchSchema (Optional[type[Serializer]]): The marshmallow schema or Pydantic model  for validating and serializing patch data.\n        DeleteSchema (Optional[type[Serializer]]): The marshmallow schema or Pydantic model  for validating and serializing delete data.\n        DetailSchema (Optional[type[Serializer]]): The marshmallow schema or Pydantic model  for serializing detail data.\n\n        pre_create_callbacks (list[type[FlaskMuckCallback]]): A list of pre-create callbacks.\n        pre_update_callbacks (list[type[FlaskMuckCallback]]): A list of pre-update callbacks.\n        pre_patch_callbacks (list[type[FlaskMuckCallback]]): A list of pre-patch callbacks.\n        pre_delete_callbacks (list[type[FlaskMuckCallback]]): A list of pre-delete callbacks.\n\n        post_create_callbacks (list[type[FlaskMuckCallback]]): A list of post-create callbacks.\n        post_update_callbacks (list[type[FlaskMuckCallback]]): A list of post-update callbacks.\n        post_patch_callbacks (list[type[FlaskMuckCallback]]): A list of post-patch callbacks.\n        post_delete_callbacks (list[type[FlaskMuckCallback]]): A list of post-delete callbacks.\n\n        searchable_columns (list[InstrumentedAttribute]): A list of columns that can be searched.\n        default_pagination_limit (int): The default pagination limit.\n        one_to_one_api (bool): Indicates whether the API represents a one-to-one relationship.\n        allowed_methods (set[str]): A set of allowed HTTP methods.\n        operator_separator (str): The separator used in filter operators.\n    \"\"\"\n\n    session: scoped_session\n    api_name: str\n    Model: SqlaModelType\n    parent: Optional[type[FlaskMuckApiView]] = None\n\n    ResponseSchema: SerializerType\n    CreateSchema: Optional[type[Schema]] = None\n    UpdateSchema: Optional[type[Schema]] = None\n    PatchSchema: Optional[type[Schema]] = None\n    DeleteSchema: Optional[type[Schema]] = None\n    DetailSchema: Optional[type[Schema]] = None\n\n    pre_create_callbacks: list[type[FlaskMuckCallback]] = []\n    pre_update_callbacks: list[type[FlaskMuckCallback]] = []\n    pre_patch_callbacks: list[type[FlaskMuckCallback]] = []\n    pre_delete_callbacks: list[type[FlaskMuckCallback]] = []\n\n    post_create_callbacks: list[type[FlaskMuckCallback]] = []\n    post_update_callbacks: list[type[FlaskMuckCallback]] = []\n    post_patch_callbacks: list[type[FlaskMuckCallback]] = []\n    post_delete_callbacks: list[type[FlaskMuckCallback]] = []\n\n    searchable_columns: list[InstrumentedAttribute] = []\n    default_pagination_limit: int = 20\n    one_to_one_api: bool = False\n    allowed_methods: set[str] = {\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"}\n    operator_separator: str = \"__\"\n\n    @property\n    def query(self) -&gt; Query:\n        return self.session.query(self.Model)\n\n    def dispatch_request(self, **kwargs: Any) -&gt; ResponseReturnValue:\n        if request.method.lower() not in [m.lower() for m in self.allowed_methods]:\n            raise MethodNotAllowed\n        return super().dispatch_request(**kwargs)\n\n    def _execute_callbacks(\n        self,\n        resource: SqlaModel,\n        kwargs: JsonDict,\n        callback_type: CallbackType,\n    ) -&gt; None:\n        attr = f\"{callback_type.value}_{METHOD_OPERATION_MAP[request.method]}_callbacks\"\n        for callback in getattr(self, attr):\n            callback(resource, kwargs).execute()\n\n    def get_base_query_kwargs(self) -&gt; JsonDict:\n        \"\"\"Returns a set of base query args. This can be overridden to add additional kwargs to the base query.\n        Useful for multi-tenant apps that need to logically separate resources by client.\n        \"\"\"\n        return {}\n\n    def _get_base_query(self) -&gt; Query:\n        base_query: Query = self.query\n        base_query = base_query.filter(*get_query_filters_from_request_path(self, []))\n        if query_kwargs := self.get_base_query_kwargs():\n            base_query = base_query.filter_by(**query_kwargs)\n        return base_query\n\n    def _get_resource(cls, resource_id: Optional[ResourceId]) -&gt; SqlaModel:\n        query = cls._get_base_query()\n        if cls.one_to_one_api:\n            return query.one()\n        return query.filter(get_pk_column(cls.Model) == resource_id).one()\n\n    def _get_clean_filter_data(self, filters: str) -&gt; JsonDict:\n        try:\n            return json.loads(filters)\n        except JSONDecodeError:\n            raise BadRequest(f\"Filters [{filters}] is not valid json.\")\n\n    def _get_kwargs_from_request_payload(self) -&gt; JsonDict:\n        \"\"\"Creates the correct schema based on request method and returns a sanitized dictionary of kwargs from the\n        request json.\n        \"\"\"\n        serializer_method_map = {\n            \"POST\": self.CreateSchema,\n            \"PUT\": self.UpdateSchema,\n            \"PATCH\": self.PatchSchema or self.UpdateSchema,\n            \"DELETE\": self.DeleteSchema,\n        }\n        serializer = serializer_method_map[request.method]\n        if not serializer:\n            raise NotImplementedError\n        kwargs = validate_payload(\n            payload=request.json or {},\n            serializer=serializer,\n            partial=request.method == \"PATCH\",\n        )\n        kwargs.update(self.get_base_query_kwargs())\n        return kwargs\n\n    @parser.use_kwargs(\n        {\n            \"limit\": fields.Integer(missing=None),\n            \"offset\": fields.Integer(missing=None),\n            \"filters\": fields.String(required=False, missing=None),\n            \"sort\": fields.String(required=False, missing=None),\n            \"search\": fields.String(required=False, missing=None),\n        },\n        location=\"querystring\",\n    )\n    def get(\n        self,\n        resource_id: Optional[ResourceId],\n        limit: Optional[int],\n        offset: Optional[int],\n        filters: Optional[str],\n        sort: Optional[str],\n        search: Optional[str],\n        **kwargs: Any,\n    ) -&gt; tuple[Union[JsonDict, list[JsonDict]], int]:\n        if resource_id or self.one_to_one_api:\n            resource = self._get_resource(resource_id)\n            if hasattr(self, \"DetailSchema\") and self.DetailSchema:\n                return serialize_model_instance(resource, self.DetailSchema), 200\n            else:\n                return (\n                    serialize_model_instance(resource, self.ResponseSchema),\n                    200,\n                )\n        else:\n            query = self._get_base_query()\n            query_filters: list = []\n            join_models: set[SqlaModelType] = set()\n            if filters:\n                _filters = self._get_clean_filter_data(filters)\n                query_filters, _join_models = self._get_query_filters(_filters)\n                join_models.update(_join_models)\n\n            # Get order by from request\n            order_by = None\n            if sort:\n                order_by, _join_models = self._get_query_order_by(sort)\n                join_models.update(_join_models)\n\n            if search:\n                search_filter, _join_models = self._get_query_search_filter(search)\n                join_models.update(_join_models)\n                if search_filter is not None:\n                    query_filters.append(search_filter)\n\n            # Apply joins, filters and order by to the query.\n            for model in join_models:\n                if model != self.Model:\n                    query = query.outerjoin(model)\n            if query_filters:\n                query = query.filter(*query_filters)\n            if order_by is not None:\n                query = query.order_by(order_by)\n            query = query.distinct()\n\n            # If offset or limit were included in the query params return paginated response object else return a flat\n            # list of all items.\n            response_data: Union[dict, list]\n            if offset or limit:\n                query_limit = limit or self.default_pagination_limit\n                query_offset = offset or 0\n                resources = query.limit(query_limit).offset(query_offset).all()\n                response_data = {\n                    \"limit\": query_limit,\n                    \"offset\": query_offset,\n                    \"total\": query.count(),\n                    \"items\": [\n                        serialize_model_instance(r, self.ResponseSchema)\n                        for r in resources\n                    ],\n                }\n            else:\n                resources = query.all()\n                response_data = [\n                    serialize_model_instance(r, self.ResponseSchema) for r in resources\n                ]\n            return response_data, 200\n\n    def _create_resource(self, kwargs: JsonDict) -&gt; SqlaModel:\n        resource = self.Model(**kwargs)\n        self.session.add(resource)\n        self.session.flush()\n        return resource\n\n    def _update_resource(self, resource: SqlaModel, kwargs: JsonDict) -&gt; SqlaModel:\n        for attr, value in kwargs.items():\n            setattr(resource, attr, value)\n        return resource\n\n    def post(self) -&gt; tuple[JsonDict, int]:\n        if not self.CreateSchema:\n            raise NotImplementedError()\n        kwargs = self.get_base_query_kwargs()\n        data = self._get_kwargs_from_request_payload()\n        kwargs.update(data)\n        try:\n            resource = self._create_resource(kwargs)\n        except IntegrityError as e:\n            self.session.rollback()\n            raise Conflict(str(e))\n        self._execute_callbacks(resource, kwargs, CallbackType.pre)\n        self.session.commit()\n        self._execute_callbacks(resource, kwargs, CallbackType.post)\n        return serialize_model_instance(resource, self.ResponseSchema), 201\n\n    def put(self, resource_id: ResourceId, **kwargs: Any) -&gt; tuple[JsonDict, int]:\n        if not self.UpdateSchema:\n            raise NotImplementedError()\n        resource = self._get_resource(resource_id)\n        kwargs = self._get_kwargs_from_request_payload()\n        resource = self._update_resource(resource, kwargs)\n        self._execute_callbacks(resource, kwargs, CallbackType.pre)\n        self.session.commit()\n        self._execute_callbacks(resource, kwargs, CallbackType.post)\n        return serialize_model_instance(resource, self.ResponseSchema), 200\n\n    def patch(self, resource_id: ResourceId, **kwargs: Any) -&gt; tuple[JsonDict, int]:\n        if not self.PatchSchema:\n            raise NotImplementedError()\n        resource = self._get_resource(resource_id)\n        kwargs = self._get_kwargs_from_request_payload()\n        resource = self._update_resource(resource, kwargs)\n        self._execute_callbacks(resource, kwargs, CallbackType.pre)\n        self.session.commit()\n        self._execute_callbacks(resource, kwargs, CallbackType.post)\n        return serialize_model_instance(resource, self.ResponseSchema), 200\n\n    def delete(self, resource_id: ResourceId, **kwargs: Any) -&gt; tuple[str, int]:\n        resource = self._get_resource(resource_id)\n        kwargs = {}\n        if self.DeleteSchema:\n            kwargs = self._get_kwargs_from_request_payload()\n        self.session.delete(resource)\n        self._execute_callbacks(resource, kwargs, CallbackType.pre)\n        self.session.commit()\n        self._execute_callbacks(resource, kwargs, CallbackType.post)\n        return \"\", 204\n\n    def _get_query_filters(\n        self, filters: JsonDict\n    ) -&gt; tuple[list[BinaryExpression], set[SqlaModelType]]:\n        \"\"\"Translates a dictionary of column names and values into a list of SQLA query filters.\n        Also returns a list of models that should be joined to the base query.\n        \"\"\"\n        query_filters: list[BinaryExpression] = []\n        join_models: set[SqlaModelType] = set()\n        for column_name, value in filters.items():\n            # Get operator.\n            operator = None\n            if self.operator_separator in column_name:\n                column_name, operator = column_name.split(self.operator_separator)\n\n            # Handle nested filters.\n            if \".\" in column_name:\n                relationship_name, column_name = column_name.split(\".\")\n                field = getattr(self.Model, relationship_name, None)\n                if not field:\n                    raise BadRequest(\n                        f\"{column_name} is not a valid filter field. The relationship does not exist.\"\n                    )\n                _Model = field.property.mapper.class_\n                join_models.add(_Model)\n            else:\n                _Model = self.Model\n\n            if not (column := getattr(_Model, column_name, None)):\n                raise BadRequest(f\"{column_name} is not a valid filter field.\")\n\n            if operator == \"gt\":\n                _filter = column &gt; value\n            elif operator == \"gte\":\n                _filter = column &gt;= value\n            elif operator == \"lt\":\n                _filter = column &lt; value\n            elif operator == \"lte\":\n                _filter = column &lt;= value\n            elif operator == \"ne\":\n                _filter = column != value\n            elif operator == \"in\":\n                _filter = column.in_(value)\n            elif operator == \"not_in\":\n                _filter = column.not_in(value)\n            else:\n                _filter = column == value\n            query_filters.append(_filter)\n        return query_filters, join_models\n\n    def _get_query_order_by(\n        self, sort: str\n    ) -&gt; tuple[Optional[UnaryExpression], set[SqlaModelType]]:\n        if self.operator_separator in sort:\n            column_name, direction = sort.split(self.operator_separator)\n        else:\n            column_name, direction = sort, \"asc\"\n\n        # Handle nested fields.\n        join_models = set()\n        if \".\" in column_name:\n            relationship_name, column_name = column_name.split(\".\")\n            field = getattr(self.Model, relationship_name, None)\n            if not field:\n                raise BadRequest(f\"{column_name} is not a valid sort field.\")\n            _Model = field.property.mapper.class_\n            join_models.add(_Model)\n        else:\n            _Model = self.Model\n\n        if hasattr(_Model, column_name):\n            column = getattr(_Model, column_name)\n            if direction == \"asc\":\n                order_by = column.asc()\n            elif direction == \"desc\":\n                order_by = column.desc()\n            else:\n                raise BadRequest(\n                    f\"Invalid sort direction: {direction}. Must asc or desc\"\n                )\n        else:\n            raise BadRequest(f\"{column_name} is not a valid sort field.\")\n        return order_by, join_models\n\n    def _get_query_search_filter(\n        self, search_string: str\n    ) -&gt; tuple[Optional[BooleanClauseList], set[SqlaModelType]]:\n        \"\"\"Returns SQLA full text search filters for the search_term provided.\"\"\"\n        if not self.searchable_columns:\n            raise BadRequest(\"Search is not supported on this endpoint.\")\n        searches = []\n        join_models = set()\n        for column in self.searchable_columns:\n            join_models.add(column.parent.class_)\n            searches.append(column.ilike(f\"%{search_string}%\"))\n        if len(searches) == 1:\n            return searches[0], join_models\n        else:\n            return or_(*searches), join_models\n\n    @classmethod\n    def add_rules_to_blueprint(cls, blueprint: Blueprint) -&gt; None:\n        \"\"\"Adds CRUD endpoints to a blueprint.\"\"\"\n        url_rule = get_url_rule(cls, None)\n        api_view = cls.as_view(f\"{cls.api_name}_api\")\n\n        # In the special case that this API represents a ONE-TO-ONE relationship, use / for all methods.\n        if cls.one_to_one_api:\n            blueprint.add_url_rule(\n                url_rule,\n                defaults={\"resource_id\": None},\n                view_func=api_view,\n                methods={\"GET\", \"PUT\", \"PATCH\", \"DELETE\"},\n            )\n\n        else:\n            # Create endpoint - POST on /\n            blueprint.add_url_rule(url_rule, view_func=api_view, methods=[\"POST\"])\n\n            # List endpoint - GET on /\n            blueprint.add_url_rule(\n                url_rule,\n                defaults={\"resource_id\": None},\n                view_func=api_view,\n                methods=[\"GET\"],\n            )\n\n            # Detail, Update, Patch, Delete endpoints - GET, PUT, PATCH, DELETE on /&lt;resource_id&gt;\n            blueprint.add_url_rule(\n                f\"{url_rule}/&lt;{get_pk_type(cls.Model)}:resource_id&gt;/\",\n                view_func=api_view,\n                methods={\"GET\", \"PUT\", \"PATCH\", \"DELETE\"},\n            )\n</code></pre>"},{"location":"api_reference/#flask_muck.views.FlaskMuckApiView.add_rules_to_blueprint","title":"<code>add_rules_to_blueprint(blueprint)</code>  <code>classmethod</code>","text":"<p>Adds CRUD endpoints to a blueprint.</p> Source code in <code>flask_muck/views.py</code> <pre><code>@classmethod\ndef add_rules_to_blueprint(cls, blueprint: Blueprint) -&gt; None:\n    \"\"\"Adds CRUD endpoints to a blueprint.\"\"\"\n    url_rule = get_url_rule(cls, None)\n    api_view = cls.as_view(f\"{cls.api_name}_api\")\n\n    # In the special case that this API represents a ONE-TO-ONE relationship, use / for all methods.\n    if cls.one_to_one_api:\n        blueprint.add_url_rule(\n            url_rule,\n            defaults={\"resource_id\": None},\n            view_func=api_view,\n            methods={\"GET\", \"PUT\", \"PATCH\", \"DELETE\"},\n        )\n\n    else:\n        # Create endpoint - POST on /\n        blueprint.add_url_rule(url_rule, view_func=api_view, methods=[\"POST\"])\n\n        # List endpoint - GET on /\n        blueprint.add_url_rule(\n            url_rule,\n            defaults={\"resource_id\": None},\n            view_func=api_view,\n            methods=[\"GET\"],\n        )\n\n        # Detail, Update, Patch, Delete endpoints - GET, PUT, PATCH, DELETE on /&lt;resource_id&gt;\n        blueprint.add_url_rule(\n            f\"{url_rule}/&lt;{get_pk_type(cls.Model)}:resource_id&gt;/\",\n            view_func=api_view,\n            methods={\"GET\", \"PUT\", \"PATCH\", \"DELETE\"},\n        )\n</code></pre>"},{"location":"api_reference/#flask_muck.views.FlaskMuckApiView.get_base_query_kwargs","title":"<code>get_base_query_kwargs()</code>","text":"<p>Returns a set of base query args. This can be overridden to add additional kwargs to the base query. Useful for multi-tenant apps that need to logically separate resources by client.</p> Source code in <code>flask_muck/views.py</code> <pre><code>def get_base_query_kwargs(self) -&gt; JsonDict:\n    \"\"\"Returns a set of base query args. This can be overridden to add additional kwargs to the base query.\n    Useful for multi-tenant apps that need to logically separate resources by client.\n    \"\"\"\n    return {}\n</code></pre>"},{"location":"api_reference/#flaskmuckcallback","title":"FlaskMuckCallback","text":"<p>             Bases: <code>ABC</code></p> <p>The base class for implementing Flask Muck callbacks.</p> Source code in <code>flask_muck/callback.py</code> <pre><code>class FlaskMuckCallback(ABC):\n    \"\"\"The base class for implementing Flask Muck callbacks.\"\"\"\n\n    def __init__(self, resource: SqlaModel, kwargs: JsonDict):\n        self.resource = resource\n        self.kwargs = kwargs\n\n    @abstractmethod\n    def execute(self) -&gt; None:\n        \"\"\"This method executes the desired callback functionality. It must be overridden in concrete subclasses.\"\"\"\n        ...\n</code></pre>"},{"location":"api_reference/#flask_muck.callback.FlaskMuckCallback.execute","title":"<code>execute()</code>  <code>abstractmethod</code>","text":"<p>This method executes the desired callback functionality. It must be overridden in concrete subclasses.</p> Source code in <code>flask_muck/callback.py</code> <pre><code>@abstractmethod\ndef execute(self) -&gt; None:\n    \"\"\"This method executes the desired callback functionality. It must be overridden in concrete subclasses.\"\"\"\n    ...\n</code></pre>"},{"location":"api_usage/","title":"How to Use the REST API","text":"<p>Having created a REST API, it's time to put it to use. This section covers each operation generated by Flask-Muck, complete with example cURL commands and descriptions.</p> <p>For this example, let's assume we have created a ToDo list application. Below is the API for managing Todo list items.</p> <pre><code>class TodoApiView(FlaskMuckApiView):\n    session = db.session\n    api_name = \"todos\"\n    Model = TodoModel\n    ResponseSchema = TodoSchema\n    CreateSchema = TodoSchema\n    PatchSchema = TodoSchema\n    UpdateSchema = TodoSchema\n    searchable_columns = [TodoModel.text]\n</code></pre>"},{"location":"api_usage/#create-a-resource","title":"Create a Resource","text":"<p>This operation creates a single new resource. The <code>CreateSchema</code> validates the request body, and the <code>ResponseSchema</code> serializes the newly created resource in the response body.</p> Example cURL Command<pre><code>curl -X POST --location \"http://127.0.0.1:5000/api/v1/todos\" \\\n    -H \"Content-Type: application/json\" \\\n    -d \"{\n            \\\"text\\\": \\\"Pick up bread and milk.\\\"\n        }\"\n</code></pre> <p>JSON Response Body<pre><code>{\n    \"id\": 1,\n    \"text\": \"Pick up bread and milk.\",\n    \"completed\": false\n}\n</code></pre> </p>"},{"location":"api_usage/#list-all-resources-flat","title":"List All Resources (Flat)","text":"<p>This returns a flat list of all resources. The <code>ResponseSchema</code> serializes the resources in the response body.</p> Example cURL Command<pre><code>curl -X GET --location \"http://127.0.0.1:5000/api/v1/todos\" \\\n    -H \"Accept: application/json\"\n</code></pre> <p>JSON Response Body<pre><code>[\n    {\n        \"id\": 1,\n        \"text\": \"Pick up bread and milk.\",\n        \"completed\": false\n    },\n    {\n        \"id\": 2,\n        \"text\": \"Take out garbage.\",\n        \"completed\": false\n    }\n]\n</code></pre> </p>"},{"location":"api_usage/#list-all-resources-paginated","title":"List All Resources (Paginated)","text":"<p>This returns a paginated set of resources. The <code>ResponseSchema</code> serializes the resources in the response body. To trigger a paginated response, provide the <code>limit</code> and/or <code>offset</code> query string parameters.</p> Example cURL Command<pre><code>curl -X GET --location \"http://127.0.0.1:5000/api/v1/todos?limit=2&amp;offset=1\" \\\n    -H \"Accept: application/json\"\n</code></pre> <p>JSON Response Body<pre><code>{\n    \"items\": [\n        {\n            \"id\": 2,\n            \"text\": \"Take out garbage.\",\n            \"completed\": false\n        },\n        {\n            \"id\": 3,\n            \"text\": \"Paint the fence.\",\n            \"completed\": false\n        }\n    ],\n    \"limit\": 2,\n    \"offset\": 1,\n    \"total\": 2\n}\n</code></pre> </p>"},{"location":"api_usage/#search-all-resources","title":"Search All Resources","text":"<p>This operation returns a list of resources matching the provided search query. The search term is matched against <code>searchable_columns</code> using an ILIKE query. The <code>ResponseSchema</code> serializes the resources in the response body.</p> Example cURL Command<pre><code>curl -X GET --location \"http://127.0.0.1:5000/api/v1/todos?search=garbage\" \\\n    -H \"Accept: application/json\"\n</code></pre> <p>JSON Response Body<pre><code>[\n    {\n        \"id\": 2,\n        \"text\": \"Take out garbage.\",\n        \"completed\": false\n    }\n]\n</code></pre> </p>"},{"location":"api_usage/#filter-all-resources","title":"Filter All Resources","text":"<p>This returns a list of resources matching the provided filters. The <code>filters</code> query string parameter is a JSON-encoded object used to filter the resources. Filtering can be done against any column on the model and supports filtering against relationships using dot notation. Operators are supported using the syntax: <code>&lt;column&gt;__&lt;operator&gt;</code> for more complex filtering. A list of available operators is provided in the table below. The <code>ResponseSchema</code> serializes the resources in the response body.</p> Operator Description None Equals <code>ne</code> Not Equals <code>lt</code> Less Than <code>lte</code> Less Than or Equal To <code>gt</code> Greater Than <code>gte</code> Greater Than or Equal To <code>in</code> In <code>not_in</code> Not In <p>An example of a complex filter using operators and relationships is <code>filters={\"list.priority__gte\": 5}</code>, filtering ToDo items whose related list has a priority greater than or equal to 5.</p> Example <p>cURL Command<pre><code>curl -X GET --location \"http://127.0.0.1:5000/api/v1/todos?filters=%7B%22text%22%3A+%22Take+out+garbage+again%22%7D\" \\\n    -H \"Accept: application/json\"\n</code></pre> query string decodes to <code>filters={\"text\": \"Take out garbage again\"}</code> </p> <p>JSON Response Body<pre><code>[\n    {\n        \"id\": 2,\n        \"text\": \"Take out garbage.\",\n        \"completed\": false\n    }\n]\n</code></pre> </p>"},{"location":"api_usage/#sort-all-resources","title":"Sort All Resources","text":"<p>This operation returns a list of resources sorted by the provided column. Use dot notation to sort by a related column and the <code>asc</code> or <code>desc</code> suffix to specify the sort order. The <code>ResponseSchema</code> serializes the resources in the response body. The default sort direction depends on your database. A complex example of sorting by a related column is <code>sort=list.priority__desc</code>.</p> Example cURL Command<pre><code>curl -X GET --location \"http://127.0.0.1:5000/api/v1/todos?sort=text__desc\" \\\n    -H \"Accept: application/json\"\n</code></pre> <p>JSON Response Body<pre><code>[\n    {\n        \"id\": 2,\n        \"text\": \"Take out garbage.\",\n        \"completed\": false\n    },\n    {\n        \"id\": 1,\n        \"text\": \"Pick up bread and milk.\",\n        \"completed\": false\n    }\n]\n</code></pre> </p> <p>Tip</p> <p>You can use any combination of search, filter, sort, and pagination query string</p> <p>parameters together.</p>"},{"location":"api_usage/#fetch-a-resource","title":"Fetch a Resource","text":"<p>This returns a single resource by its primary key. The <code>DetailSchema</code> serializes the response. If <code>DetailSchema</code> does not exist, Flask-Muck falls back to using the <code>ResponseSchema</code>.</p> Example cURL Command<pre><code>curl -X GET --location \"http://127.0.0.1:5000/api/v1/todos/1\" \\\n    -H \"Accept: application/json\"\n</code></pre> <p>JSON Response Body<pre><code>{\n    \"id\": 1,\n    \"text\": \"Pick up bread and milk.\",\n    \"completed\": false\n}\n</code></pre> </p>"},{"location":"api_usage/#update-a-resource","title":"Update a Resource","text":"<p>This updates a single resource by its primary key. The <code>UpdateSchema</code> validates the request body. The update endpoint adheres to PUT semantics, intending to replace the entire resource with the provided data. For partial updates, use the PATCH endpoint. The <code>ResponseSchema</code> serializes the response.</p> Example cURL Command<pre><code>curl -X PUT --location \"http://127.0.0.1:5000/api/v1/todos/1\" \\\n    -H \"Content-Type: application/json\" \\\n    -d \"{\n            \\\"text\\\": \\\"Updated todo item\\\",\n            \\\"completed\\\": true \n        }\"\n</code></pre> <p>JSON Response Body<pre><code>{\n    \"id\": 1,\n    \"text\": \"Updated todo item\",\n    \"completed\": true\n}\n</code></pre> </p>"},{"location":"api_usage/#patch-a-resource","title":"Patch a Resource","text":"<p>This updates a single resource by its primary key. The PATCH endpoint adheres to PATCH semantics, intended for partial updates. If the <code>PatchSchema</code> does not exist, Flask-Muck falls back to using the <code>UpdateSchema</code>. The schema is initialized with <code>partial=True</code> to allow partial updates. The <code>ResponseSchema</code> serializes the response.</p> Example cURL Command<pre><code>curl -X PATCH --location \"http://127.0.0.1:5000/api/v1/todos/1\" \\\n    -H \"Content-Type: application/json\" \\\n    -d \"{\n            \\\"completed\\\": true \n        }\"\n</code></pre> <p>JSON Response Body<pre><code>{\n    \"id\": 1,\n    \"text\": \"Pick up bread and milk.\",\n    \"completed\": true\n}\n</code></pre> </p>"},{"location":"api_usage/#delete-a-resource","title":"Delete a Resource","text":"<p>This deletes a single resource by its primary key. The <code>ResponseSchema</code> serializes the response. Optionally, the <code>DeleteSchema</code> can validate the request body if additional custom logic occurs during a delete operation. If the schema does not exist, the resource is deleted. The response is always empty.</p> Example <p>cURL Command<pre><code>curl -X DELETE --location \"http://127.0.0.1:5000/api/v1/todos/1\"\n</code></pre> </p>"},{"location":"callbacks/","title":"Pre/Post Callbacks","text":"<p>As most projects evolve, simple CRUD actions often become insufficient. APIs may need to perform complex validations, possibly requiring checks against external services, or execute additional actions after CRUD operations like sending emails, starting asynchronous tasks, or adding audit information.</p> <p>Flask-Muck provides an easy-to-use callback system that allows you to define functions and execute them before or after any CRUD operation.</p> <p>These functions are defined by creating <code>FlaskMuckCallback</code> subclasses. A <code>FlaskMuckCallback</code> has a single method, <code>execute</code>, that must be overridden. This method takes no arguments and returns <code>None</code>. Override this function with any logic that needs to occur before or after a CRUD operation.</p> <p>The <code>execute</code> method has access to two attributes: <code>self.resource</code> and <code>self.kwargs</code>.</p> Attribute Description resource The SqlAlchemy model instance affected by the operation. kwargs A dictionary of keyword arguments used to execute the CRUD operation. This is a union of kwargs sent in the JSON payload and any returned by the <code>get_base_query_kwargs</code> method. You can read more about <code>get_base_query_kwargs</code> in the Supporting Logical Data Separation (Multi-tenancy) section. <p>The <code>FlaskMuckCallback</code> class is then added to pre or post callback lists on a <code>FlaskMuckApiView</code>. There is a class variable for the pre and post callback list for each CRUD operation. The names of these class variables follow this naming convention: <code>&lt;pre_or_post&gt;_&lt;operation&gt;_callbacks</code>.</p> <pre><code>import logging\nfrom flask import request\nfrom flask_muck import FlaskMuckCallback, FlaskMuckApiView\n\nclass LogCallback(FlaskMuckCallback):\n    def execute(self) -&gt; None:\n        logging.info(f\"{request.method=} {self.resource=} {self.kwargs=}\")\n\nclass MyApiView(FlaskMuckApiView):\n    ...\n    post_create_callbacks = [LogCallback]\n    post_patch_callbacks = [LogCallback]\n    post_update_callbacks = [LogCallback]\n    post_delete_callbacks = [LogCallback]\n</code></pre> <p>Tip</p> <p>You can add any number of callbacks to a callback list. The callbacks are executed serially and in order. Keep this in mind if the effects of some callbacks may influence others.</p>"},{"location":"callbacks/#example-usage","title":"Example Usage","text":"<p>Note</p> <p>This example expands on the one in the quickstart. If you haven't read through the quickstart, it will make more sense if you do.</p> <p>This scenario represents an app that tracks teachers and students. The requirements for the app are:</p> <ul> <li>Teachers' credentials must be verified against an external service before they can be added.</li> <li>All modification actions need to be added to the audit log for compliance.</li> <li>When a student or teacher is added, they will be sent a welcome email.</li> </ul> myapp/models.py<pre><code>from myapp import db\n\nclass Teacher(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String, nullable=False)\n    email = db.Column(db.String, nullable=False)\n    years_teaching = db.Column(db.Integer)\n\nclass Student(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String, nullable=False)\n    email = db.Column(db.String, nullable=False)\n    parent_id = db.Column(db.ForeignKey(Teacher.id))\n    parent = db.relationship(Teacher)\n</code></pre> myapp/callbacks.py<pre><code>from flask import request\nfrom flask_login import current_user\nfrom flask_muck import FlaskMuckCallback\n\nfrom myapp.utils import add_audit_log#(1)!\nfrom myapp.utils import verify_teacher#(2)!\nfrom myapp.utils import send_welcome_email#(3)!\n\nclass VerifyTeacherCredentialsCallback(FlaskMuckCallback):\n    \"\"\"Check external service to verify a teacher has the correct teaching credentials.\"\"\"\n    def execute(self) -&gt; None:\n        verify_teacher(self.resource.name)\n\nclass AuditLogCallback(FlaskMuckCallback):\n    \"\"\"Adds a record to the audit log for SOC2 compliance.\"\"\"\n    def execute(self) -&gt; None:\n        add_audit_log(\n            user=current_user,\n            operation=request.method,\n            resource_type=type(self.resource),\n            resource_id=self.resource.id,\n            kwargs=self.kwargs,\n        )\n\nclass SendWelcomeEmailCallback(FlaskMuckCallback):\n    \"\"\"Sends a welcome email to newly created students or teachers.\"\"\"\n    def execute(self) -&gt; None:\n        send_welcome_email(name=self.resource.name, email=self.resource.email)\n</code></pre> <ol> <li><code>add_audit_log</code> is a function that adds a record to an audit log used for compliance purposes.</li> <li><code>verify_teacher</code> is a function that makes a request to an external service to verify a teacher's credentials. If the proper credentials are not present, an exception is raised.</li> <li><code>send_welcome_email</code> is a function that sends a welcome email to a student or teacher when they are added to the application.</li> </ol> myapp/schemas.py<pre><code>from marshmallow import Schema\nfrom marshmallow import fields as mf\n\nclass TeacherSchema(Schema):\n    id = mf.Integer(dump_only=True)\n    name = mf.String(required=True)\n    email = mf.String(required=True)\n    years_teaching = mf.Integer()\n\nclass StudentSchema(Schema):\n    id = mf.Integer(dump_only=True)\n    email = mf.String(required=True)\n    name = mf.String(required=True)\n</code></pre> myapp/views.py<pre><code>from flask_muck import FlaskMuckApiView\nfrom myapp import db\nfrom myapp.auth.decorators import login_required\nfrom myapp.models import Teacher, Student\nfrom myapp.schemas import TeacherSchema, StudentSchema\nfrom myapp.callbacks import VerifyTeacherCredentialsCallback, AuditLogCallback, SendWelcomeEmailCallback\n\nclass BaseApiView(FlaskMuckApiView):\n    session = db.session\n    decorators = [login_required]\n\nclass TeacherApiView(BaseApiView):\n    api_name = \"teachers\" \n    Model = Teacher \n    ResponseSchema = TeacherSchema \n    CreateSchema = TeacherSchema \n    PatchSchema = TeacherSchema \n    UpdateSchema = TeacherSchema \n\n    pre_create_callbacks = [VerifyTeacherCredentialsCallback]#(1)!\n    post_create_callbacks = [AuditLogCallback, SendWelcomeEmailCallback]#(2)!\n    post_patch_callbacks = [AuditLogCallback]\n    post_update_callbacks = [AuditLogCallback]\n    post_delete_callbacks = [AuditLogCallback]\n\nclass StudentApiView(BaseApiView):\n    api_name = \"students\" \n    Model = Student \n    parent = TeacherApiView\n    ResponseSchema = StudentSchema \n    CreateSchema = StudentSchema \n    PatchSchema = StudentSchema \n    UpdateSchema = StudentSchema\n\n    post_create_callbacks = [AuditLogCallback, SendWelcomeEmailCallback]\n    post_patch_callbacks = [AuditLogCallback]\n    post_update_callbacks = [AuditLogCallback]\n    post_delete_callbacks = [AuditLogCallback]\n</code></pre> <ol> <li>The <code>pre_create_callbacks</code> are used to validate the teacher before they are added.</li> <li>Note that you can add as many callbacks as you like. They will be executed serially and in order</li> </ol>"},{"location":"configuration/","title":"Configuration","text":"<p>Configuration in Flask-Muck is handled entirely through setting class variables on <code>FlaskMuckApiView</code>. As noted in the quickstart, you will likely have some class variable settings that are shared by most or all of your view classes. It's advisable to set up base classes to handle sharing configuration between views.</p>"},{"location":"configuration/#flaskmuckapiview-class-variables","title":"FlaskMuckApiView Class Variables","text":"Class Variable Description Required session <code>scoped_session</code> SqlAlchemy database session used to query and modify the resource. api_name <code>str</code> Name of the API. Used as the url path appended to your Flask Blueprint. Model <code>SqlaModelType</code> SqlAlchemy Model used to make queries. ResponseSchema <code>SerializerType</code> Marshmallow schema or Pydantic model used to serialize the resource returned by any of the views. decorators <code>list[Callable]</code> List of decorators to apply to all views in the API. This is inherited functionality built into Flask's class-based views. parent <code>Optional[type[FlaskMuckApiView]]</code> If set, this API becomes a nested resource API. For more information on nested APIs see the documentation. CreateSchema <code>Optional[SerializerType]]</code> Marshmallow schema or Pydantic model used to validate the POST request JSON payload sent to create a resource. UpdateSchema <code>Optional[SerializerType]]</code> Marshmallow schema or Pydantic model used to validate the PUT request JSON payload sent to update a resource. PatchSchema <code>Optional[SerializerType]]</code> Marshmallow schema or Pydantic model used to validate the PATCH request JSON payload sent to patch a resource. DeleteSchema <code>Optional[SerializerType]]</code> Marshmallow schema or Pydantic model used to validate the DELETE request JSON payload sent to create a resource. Optional. DetailSchema <code>Optional[SerializerType]]</code> Optional Marshmallow schema or Pydantic model used to serialize the resource returned by the GET /&lt;api_name&gt;/&lt;ID&gt;/ endpoint. If this schema is not set the ResponseSchema is used. pre_create_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called before a resource is created. Ideal for validation. pre_update_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called before a resource is updated. Ideal for validation. pre_patch_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called before a resource is patched. Ideal for validation. pre_delete_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called before a resource is deleted. Ideal for validation. post_create_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called after a resource is created. Useful for activities such as notifications. Called post commit. post_update_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called after a resource is updated. Useful for activities such as notifications. Called post commit. post_patch_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called after a resource is patched. Useful for activities such as notifications. Called post commit. post_delete_callbacks <code>list[type[FlaskMuckCallback]]</code> List of callback classes to be called after a resource is deleted. Useful for activities such as notifications. Called post commit. searchable_columns <code>list[InstrumentedAttribute]</code> List of Model columns that will be queried using an \"ILIKE\" statement when the <code>search=</code> query param is used on the GET /resource/ endpoint. default_pagination_limit <code>int</code> Default pagination limit when retrieving paginated results on the GET /&lt;api_name&gt;/ endpoint. Default is 20. one_to_one_api <code>bool</code> If True, this API is treated as a one-to-one relationship and the GET /&lt;api_name&gt;/ endpoint will return a single resource. Generally used in combination with the <code>parent</code> setting. allowed_methods <code>set[str]</code> Set of allowed HTTP methods for this API. Default is <code>{\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"}</code>. This setting is used to control which actions are available for this resource. Not including a method affects which routes will be registered to a Flask Blueprint. operator_separator <code>str</code> Separator used when assigning operators to search or filter query parameters in the GET /&lt;api_name&gt;/ endpoint. Default is <code>\"__\"</code>."},{"location":"configuration/#base-class-example","title":"Base Class Example","text":"<p>Suppose you have an API with the following requirements for all views:</p> <ul> <li>Authentication decorator.</li> <li>Permission checking decorator.</li> <li>No allowance for patches.</li> <li>Uses \"|\" as the operator separator for filters.</li> <li>Uses the standard database session.</li> </ul> <p>The best way to handle this is to create a base API view that all other API views inherit from.</p> Base Class<pre><code>class BaseApiView(FlaskMuckApiView):\n    session = db.session\n    decorators = [login_required, permission_required]\n    allowed_methods = {\"GET\", \"POST\", \"PUT\", \"DELETE\"}\n    operator_separator = \"|\"\n</code></pre> Concrete Class<pre><code>class TurtleApiView(BaseApiView):#(1)!\n    api_name = 'turtles'\n    Model = Turtle\n    ...#(2)!\n</code></pre> <ol> <li>The concrete view inherits from BaseApiView and all of its configurations.</li> <li>The remainder of the class variables are configured as normal.</li> </ol>"},{"location":"escape_hatches/","title":"Escape Hatches","text":"<p>Flask-Muck is designed to handle standard CRUD endpoints efficiently, but it's not intended to cover 100% of your API needs. Inevitably, you'll require more specific or targeted endpoints. Flask-Muck is flexible, allowing integration with other Flask method-based or class-based views.</p> <p>This chapter covers various \"escape hatches\" that enable you to step outside Flask-Muck's logic, adding custom endpoints to your API or altering Flask-Muck's internal operations.</p>"},{"location":"escape_hatches/#using-allowed_methods-settings-to-omit-endpoints","title":"Using <code>allowed_methods</code> Settings to Omit Endpoint(s)","text":"<p>The <code>allowed_methods</code> class variable lets you omit certain endpoints from being added by Flask-Muck. This is useful if you wish to implement a custom endpoint for a specific HTTP method. A common scenario is an API with a complex creation operation, while the rest of the CRUD operations are straightforward.</p> <pre><code>blueprint = Blueprint(\"api\", __name__, url_prefix=\"/api/\")\n\nclass MyModelApiView(FlaskMuckApiView):\n    api_name = \"my-model\"\n    session = db.session\n    Model = MyModel\n    ResponseSchema = MyModelSchema\n    CreateSchema = MyModelSchema\n    PatchSchema = MyModelSchema\n    UpdateSchema = MyModelSchema\n    searchable_columns = [MyModel.name]\n    allowed_methods = {\"GET\", \"PATCH\", \"PUT\", \"DELETE\"}#(1)!\n\nMyModelApiView.add_rules_to_blueprint(blueprint)\n\n@blueprint.route(\"/api/v1/my-model\", methods=[\"POST\"])\ndef create_my_model():\n    ...#(2)!\n</code></pre> <ol> <li>The \"POST\" method is omitted from the <code>allowed_methods</code> set, preventing Flask-Muck from adding a create endpoint.</li> <li>Implement your custom create logic here.</li> </ol> <p>The <code>allowed_methods</code> setting can also be used to create read-only APIs (e.g., <code>allowed_methods = {\"GET\"}</code>).</p>"},{"location":"escape_hatches/#overriding-create-and-update-logic","title":"Overriding Create and Update Logic","text":"<p>FlaskMuckApiView has two simple methods for creating (POST) and updating (PUT/PATCH) resources:</p> <pre><code>    def _create_resource(self, kwargs: JsonDict) -&gt; SqlaModel:\n        resource = self.Model(**kwargs)\n        self.session.add(resource)\n        self.session.flush()\n        return resource\n\n    def _update_resource(self, resource: SqlaModel, kwargs: JsonDict) -&gt; SqlaModel:\n        for attr, value in kwargs.items():\n            setattr(resource, attr, value)\n        return resource\n</code></pre> <p>These methods are designed as override points, allowing customization of resource creation and updating. For instance, if all your models have a <code>create</code> class method for resource creation, you could override <code>_create_resource</code> to use this method instead of the default constructor:</p> <pre><code>    def _create_resource(self, kwargs: JsonDict) -&gt; SqlaModel:\n        resource = self.Model.create(**kwargs)\n        return resource\n</code></pre>"},{"location":"escape_hatches/#customizing-keyword-arguments-passed-to-all-operations","title":"Customizing Keyword Arguments Passed to All Operations","text":"<p>You might want to customize the keyword arguments passed to all operations. FlaskMuckApiView's <code>get_base_query_kwargs</code> method can be overridden for this purpose:</p> <pre><code>    def get_base_query_kwargs(self) -&gt; JsonDict:\n        return {}\n</code></pre> <p>For example, if you have a <code>deleted</code> column for soft-deleting resources, you could override <code>get_base_query_kwargs</code> to filter out deleted resources and ensure new or updated resources aren't marked as deleted:</p> <pre><code>    def get_base_query_kwargs(self) -&gt; JsonDict:\n        return {\"deleted\": False}\n</code></pre> <p>A more detailed example using this method can be found in the Supporting Logical Data Separation (Multi-tenancy) chapter.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#pip","title":"pip","text":"<p>Flask-Muck is currently only available on PyPi and can be installed with pip.</p> <p><code>pip install flask-muck</code></p>"},{"location":"logical_separation/","title":"Supporting Logical Data Separation (Multi-tenancy)","text":"<p>A common architecture in web applications is multi-tenancy through logical separation. <code>FlaskMuckApiView</code> includes a method, <code>get_base_query_kwargs</code>, which can be overridden to generate a set of arguments passed to all queries. This method enables filtering of resources to those available to a user, preventing resource leakage between tenants.</p> <p>The <code>get_base_query_kwargs</code> should return a dictionary of keyword arguments. These kwargs are applied to CRUD operations at the SqlAlchemy level. For example, the GET /&lt;resource&gt;/ endpoint will generate the query <code>Model.query.filter_by(**get_base_query_kwargs()).all()</code> instead of <code>Model.query.all()</code>. The keyword arguments are also applied when creating or updating a model.</p> <pre><code>from flask_login import current_user\nfrom flask_muck import FlaskMuckApiView\n\nclass MyApiView(FlaskMuckApiView):\n    ...\n\n    def get_base_query_kwargs(self):\n        return {\"organization_id\": current_user.organization_id}#(1)!\n</code></pre> <ol> <li>Assumes the resource has an <code>organization_id</code> column and it will be filtered by the current user's organization ID.</li> </ol>"},{"location":"logical_separation/#example-usage","title":"Example Usage","text":"<p>Note</p> <p>This example builds upon the quickstart example. It will be more comprehensible if you have read through the quickstart.</p> <p>Imagine a customer support platform where each user belongs to a single organization. Nearly all resources in the application are associated with an organization, and users should only access resources within their organization.</p> <p>The SqlAlchemy models might look like this:</p> myapp/models.py<pre><code>from myapp import db\n\nclass Organization(db.Model):\n    \"\"\"Customer support organization containing users and support tickets.\"\"\"\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    name = db.Column(db.String, nullable=False)\n\nclass User(db.Model):\n    \"\"\"User responsible for responding to support tickets in their organization.\"\"\"\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    email = db.Column(db.String, nullable=False)\n    organization_id = db.Column(db.ForeignKey(Organization.id))\n    organization = db.relationship(Organization)\n\nclass SupportTicket(db.Model):\n    \"\"\"Support ticket submitted for an organization.\"\"\"\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    order_number = db.Column(db.Integer, nullable=False)\n    organization_id = db.Column(db.ForeignKey(Organization.id))\n    organization = db.relationship(Organization)\n\nclass NewsfeedItem(db.Model):\n    \"\"\"Newsfeed item with platform information (e.g., release notes), available to all users regardless of organization.\"\"\"\n    id = db.Column(db.Integer, primary_key=True, autoincrement=True)\n    text = db.Column(db.String, nullable=False)\n</code></pre> <p>Since we have views that need to be filtered by organization and others that do not, two base classes will be created:</p> myapp/baseviews.py<pre><code>from flask_login import login_required, current_user\nfrom flask_muck import FlaskMuckApiView\nfrom myapp import db\n\nclass BaseApiView(FlaskMuckApiView):\n    session = db.session\n    decorators = [login_required]#(1)!\n\nclass OrganizationResourceApiView(BaseApiView):\n    def get_base_query_kwargs(self):\n        return {\"organization_id\": current_user.organization_id}#(2)!\n</code></pre> <ol> <li>Flask-Login enforces user authentication by adding the <code>login_required</code> decorator.</li> <li>Flask-Login provides access to the current user, allowing views to filter by the current organization.</li> </ol> <p>Now, simply choose the appropriate base view class based on whether the resource should be filtered by the current user's organization:</p> views.py<pre><code>from myapp.baseviews import BaseApiView, OrganizationResourceApiView\nfrom myapp.models import SupportTicket, NewsfeedItem\n\nclass SupportTicketsApiView(OrganizationResourceApiView):\n    Model = SupportTicket\n    ...#(1)!\n\nclass NewsfeedItemApiview(BaseApiView):\n    Model = NewsfeedItem\n    ...#(2)!\n</code></pre> <ol> <li>The remainder of the <code>SupportTicketsApiView</code> configuration goes here.</li> <li>The remainder of the <code>NewsfeedItemApiview</code> configuration goes here.</li> </ol>"},{"location":"nesting_apis/","title":"Nesting Resource APIs","text":"<p>Nesting hierarchical resources in a REST API is a common practice. Flask-Muck provides support for generating nested APIs if the SqlAlchemy models are related by a basic foreign key relationship. Nested APIs automatically handle filtering child resources and supplying the parent ID as input during the Create operation.</p> <p>Creating a nested relationship is as simple as setting the <code>parent</code> class variable of a <code>FlaskMuckApiView</code> to another <code>FlaskMuckApiView</code> whose <code>Model</code> has a valid foreign key relationship.</p> <pre><code>from flask import Blueprint\nfrom flask_muck import FlaskMuckApiView\nfrom myapp import db\nfrom myapp.models import Parent, Child\nfrom myapp.schemas import ParentSchema, ChildSchema\n\nclass ParentApiView(FlaskMuckApiView):\n    api_name = \"parents\"\n    session = db.session\n    Model = Parent\n    ResponseSchema = ParentSchema\n    CreateSchema = ParentSchema\n    PatchSchema = ParentSchema\n    UpdateSchema = ParentSchema\n\nclass ChildApiView(FlaskMuckApiView):\n    api_name = \"children\"\n    session = db.session\n    parent = ParentApiView#(1)!\n    Model = Child#(2)!\n    ResponseSchema = ChildSchema\n    CreateSchema = ChildSchema\n    PatchSchema = ChildSchema\n    UpdateSchema = ChildSchema\n\nblueprint = Blueprint(\"api\", __name__, url_prefix=\"/api/\")\nParentApiView.add_rules_to_blueprint(blueprint)\nChildApiView.add_rules_to_blueprint(blueprint)\n</code></pre> <ol> <li>Setting the <code>parent</code> class variable to another <code>FlaskMuckApiView</code> is all that is needed to set up nesting.</li> <li>The <code>Child</code> model must have a foreign key column that references the <code>Parent</code> model.</li> </ol> <p>This setup produces the following nested API resources:</p> URL Path Method Description /api/parents/ GET List all parents /api/parents/ POST Create a parent /api/parents/&lt;ID&gt;/ GET Fetch a parent /api/parents/&lt;ID&gt;/ PUT Update a parent /api/parents/&lt;ID&gt;/ PATCH Patch a parent /api/parents/&lt;ID&gt;/ DELETE Delete a parent /api/parents/&lt;ID&gt;/children/ GET List all children of a parent /api/parents/&lt;ID&gt;/children/ POST Create a child foreign keyed to a parent. /api/parents/&lt;ID&gt;/children/&lt;ID&gt;/ GET Fetch a child /api/parents/&lt;ID&gt;/children/&lt;ID&gt;/ PUT Update a child /api/parents/&lt;ID&gt;/children/&lt;ID&gt;/ PATCH Patch a child /api/parents/&lt;ID&gt;/children/&lt;ID&gt;/ DELETE Delete a child <p>Tip</p> <p>Nesting APIs works recursively, allowing for multiple levels of nesting.</p> <p>Warning</p> <p>Nested APIs may not function correctly if your models do not use standard integer or UUID primary keys.</p>"},{"location":"nesting_apis/#usage-example","title":"Usage Example","text":"<p>Note</p> <p>This example builds upon the quickstart example. It will be more comprehensible if you have read through the quickstart.</p> <p>Suppose you want to add a nested endpoint to the teacher detail endpoint from the quickstart, allowing you to manage all of a teacher's students.</p> <p>Below are the necessary models, schemas, and views:</p> myapp/models.py<pre><code>from myapp import db\n\nclass Teacher(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String, nullable=False)\n    years_teaching = db.Column(db.Integer)\n\nclass Student(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String, nullable=False)\n    parent_id = db.Column(db.ForeignKey(Teacher.id))\n    parent = db.relationship(Teacher)\n</code></pre> myapp/schemas.py<pre><code>from marshmallow import Schema\nfrom marshmallow import fields as mf\n\n\nclass TeacherSchema(Schema):\n    id = mf.Integer(dump_only=True)\n    name = mf.String(required=True)\n    years_teaching = mf.Integer()\n\nclass StudentSchema(Schema):\n    id = mf.Integer(dump_only=True)\n    name = mf.String(required=True)\n</code></pre> myapp/views.py<pre><code>from flask_muck import FlaskMuckApiView\nfrom myapp import db\nfrom myapp.auth.decorators import login_required\nfrom myapp.models import Teacher, Student\nfrom myapp.schemas import TeacherSchema, StudentSchema\n\n\nclass BaseApiView(FlaskMuckApiView):\n    session = db.session\n    decorators = [login_required]\n\n\nclass TeacherApiView(BaseApiView):\n    api_name = \"teachers\" \n    Model = Teacher \n    ResponseSchema = TeacherSchema \n    CreateSchema = TeacherSchema \n    PatchSchema = TeacherSchema \n    UpdateSchema = TeacherSchema \n    searchable_columns = [Teacher.name] \n\n\nclass StudentApiView(BaseApiView):\n    api_name = \"students\" \n    Model = Student \n    parent = TeacherApiView\n    ResponseSchema = StudentSchema \n    CreateSchema = StudentSchema \n    PatchSchema = StudentSchema \n    UpdateSchema = StudentSchema \n    searchable_columns = [Student.name]\n</code></pre>"},{"location":"quickstart/","title":"Quick Start","text":"<p>Flask-Muck provides standard REST APIs for resources in your Flask/SqlAlchemy application. This  is accomplishing by creating subclasses of the FlaskMuckApiView and configuring them by setting a series of class variables.</p> <p>The quick start guide will walk you through creating your first basic API. The subsequent chapters cover using the APIs and configuring advanced features.</p>"},{"location":"quickstart/#define-a-base-view","title":"Define a base view","text":"<p>Flask-Muck works by subclassing the FlaskMuckApiView and setting class variables on the concrete view classes. In almost  all projects there will be a basic set of class variables shared by all FlaskMuckApiView subclasses. The two most common  settings to be shared across all views is the database session used for committing changes and a set of  decorators that should be applied to all views.</p> <p>In this example a base class is defined with the app's database session and authentication decorator set.</p> <p>Application using SqlAlchemy in Flask session setup: <pre><code>from flask_muck import FlaskMuckApiView\nfrom myapp.database import db_session \nfrom myapp.auth.decorators import login_required\n\n\nclass BaseApiView(FlaskMuckApiView):\n    session = db_session\n    decorators = [login_required]\n</code></pre></p> <p>Application using Flask-SqlAlchemy extension: <pre><code>from flask_muck import FlaskMuckApiView\nfrom myapp import db\nfrom myapp.auth.decorators import login_required\n\n\nclass BaseApiView(FlaskMuckApiView):\n    session = db.session\n    decorators = [login_required]\n</code></pre></p> <p>Note</p> <p>For the remainder of this guide we'll assume usage of the Flask-SqlAlchemy extension.</p>"},{"location":"quickstart/#create-sqlalchemy-model","title":"Create SQLAlchemy Model","text":"<p>Flask-Muck requires the use of SQLAlchemy's declarative system. If you are not using the declarative system, you will need to review those docs and re-evaluate whether Flask-Muck is the right choice for your project. Explaining the full process of creating and registering a SQLAlchemy model in your Flask app is outside the scope of this guide. The example code below shows the model class we will be creating an API for in the rest of the guide.</p> <pre><code>from myapp import db\n\nclass Teacher(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String, nullable=False)\n    years_teaching = db.Column(db.Integer)\n</code></pre>"},{"location":"quickstart/#create-request-and-response-schemas","title":"Create Request and Response Schemas","text":"<p>Flask-Muck requires configuring Marshmallow and/or Pydantic classes that will be used to validate the payload data for  the Create, Update, Patch, and (optionally) Delete endpoints. Additionally, a schema must be supplied that will  serialize the endpoint's resource in responses. In this example, a simple schema is defined that can be re-used for  all validation and serialization. In this example you'll be defining Marshmallow schemas. </p> <p>Tip</p> <p>In v0.2.0 and higher, Pydantic models can also be used as schemas. You can see an example app using Pydantic models here</p> <pre><code>from marshmallow import Schema, fields as mf\n\nclass TeacherSchema(Schema):\n    id = mf.Integer(dump_only=True)\n    name = mf.String(required=True)\n    years_teaching = mf.Integer()\n</code></pre>"},{"location":"quickstart/#create-concrete-flaskmuckapiview","title":"Create Concrete FlaskMuckApiView","text":"<p>Inherit from the project's base API view class and define the required class variables.</p> <pre><code>class TeacherApiView(BaseApiView):\n    api_name = \"teachers\" #(1)!\n    Model = Teacher #(2)!\n    ResponseSchema = TeacherSchema #(3)!\n    CreateSchema = TeacherSchema #(4)!\n    PatchSchema = TeacherSchema #(5)!\n    UpdateSchema = TeacherSchema #(6)!\n    searchable_columns = [Teacher.name] #(7)!\n</code></pre> <ol> <li>Name used as the URL endpoint in the REST API.</li> <li>Model class that will be queried and updated by this API.</li> <li>Marshmallow schema used to serialize Teachers returned by the API.</li> <li>Marshmallow schema used to validate payload data sent to the Create endpoint.</li> <li>Marshmallow schema used to validate payload data sent to the Patch endpoint.</li> <li>Marshmallow schema used to validate payload data sent to the Update endpoint.</li> <li>List of model columns that can be searched when listing Teachers using the API.</li> </ol>"},{"location":"quickstart/#add-url-rules-to-a-flask-blueprint","title":"Add URL Rules to a Flask Blueprint","text":"<p>The final step is to add the correct URL rules to an existing Flask Blueprint object. A class method is included that handles adding all necessary rules to the given Blueprint.</p> <pre><code>from flask import Blueprint\n\nblueprint = Blueprint(\"api\", __name__, url_prefix=\"/api/\")\nTeacherApiView.add_rules_to_blueprint(blueprint)\n</code></pre> <p>This setup produces the following views for a standard REST API:</p> URL Path Method Description /api/teachers/ GET List all teachers - querystring options available for sorting, filtering, searching, and pagination /api/teachers/ POST Create a teacher /api/teachers/\\ GET Fetch a single teacher /api/teachers/\\ PUT Update a single teacher /api/teachers/\\ PATCH Patch a single teacher /api/teachers/\\ DELETE Delete a single teacher"}]}